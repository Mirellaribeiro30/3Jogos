<!DOCTYPE html>
<!-- Declara que este é um documento HTML5 -->
<html lang="pt-BR">
<!-- Define o idioma do conteúdo como Português do Brasil -->
<head>
<meta charset="UTF-8">
<!-- Define a codificação de caracteres como UTF-8 -->
<title>Falling Objects Game</title>
<!-- Título que aparece na aba do navegador -->

<style>
/* --- Estilos gerais da página --- */
html, body {
  margin:0; padding:0; width:100%; height:100%;
  /* Remove margens e padding padrão e ocupa 100% da tela */
  background:#111; /* Fundo escuro da página */
  overflow:hidden; /* Remove barras de rolagem */
  font-family:Arial; /* Fonte utilizada no jogo */
  display:flex; justify-content:center; align-items:center;
  /* Centraliza os elementos da página horizontal e verticalmente */
}

/* Canvas onde o jogo é desenhado */
canvas {
  background:#222; /* Fundo do canvas mais escuro que o body */
  border:2px solid #555; /* Borda cinza */
  display:block; /* Exibe como bloco */
}

/* HUD (Head-Up Display) - mostra pontuação e vidas */
#hud {
  position:fixed; /* Fica fixo na tela mesmo se rolasse */
  top:10px; left:10px; /* Distância do topo e da esquerda */
  color:white; font-size:20px; /* Cor e tamanho do texto */
  display:none; /* Inicialmente escondido */
}

/* Telas do jogo (start, instruções, game over) */
.screen {
  position:fixed; top:0; left:0; width:100%; height:100%;
  display:flex; justify-content:center; align-items:center;
  flex-direction:column; /* Organiza elementos em coluna */
  background:#111; /* Fundo escuro */
  color:white; /* Texto branco */
}

/* Input para número de vidas */
.screen input {
  width:50px; font-size:20px; text-align:center;
}

/* Botões */
.screen button {
  margin-top:20px;
  padding:10px 20px;
  font-size:20px;
  cursor:pointer; /* Cursor de mão ao passar sobre o botão */
}

/* Tela de Game Over */
#gameOverScreen { display:none; background:rgba(0,0,0,0.7); }

/* Tela de Instruções */
#instructionScreen {
  display:none; /* Escondido inicialmente */
  background: rgba(0,0,0,0.9); /* Fundo quase preto */
  text-align: center; /* Centraliza o texto */
  padding: 40px; /* Espaçamento interno */
  position: relative; /* Para posicionar o botão X */
  box-sizing: border-box;
}

/* Botão de fechar instruções */
#instructionScreen button {
  position: absolute;
  top: 10px; right: 10px;
  font-size: 20px;
  cursor: pointer;
}
</style>
</head>

<body>
<!-- Tela inicial de escolha de vidas -->
<div id="startScreen" class="screen">
  <h1>Escolha o número de vidas</h1>
  <input type="number" id="lifeInput" value="3" min="1" max="5">
  <!-- Input para escolher de 1 a 5 vidas -->
  <button id="startButton">Começar</button>
</div>

<!-- Tela de instruções -->
<div id="instructionScreen" class="screen">
  <h1>Instruções do Jogo</h1>
  <p>Desvie dos asteroides e colete as estrelas para aumentar a pontuação.</p>
  <p>Use o mouse para mover a nave.</p>
  <button id="closeInstructions">X</button>
</div>

<!-- HUD do jogo -->
<div id="hud">
  <div id="score">Pontuação: 0</div>
  <div id="lives">Vidas: 3</div>
</div>

<!-- Canvas onde o jogo acontece -->
<canvas id="gameCanvas" width="600" height="800" style="display:none;"></canvas>

<!-- Tela de Game Over -->
<div id="gameOverScreen" class="screen">
  <h1>GAME OVER</h1>
  <p id="finalScore"></p>
  <button id="restartButton">Reiniciar</button>
</div>

<script>
// --- ÁUDIO ---
// Sons do jogo
const starSound = new Audio('star.mp3'); // Som ao pegar estrela
const hitSound = new Audio('hit.mp3');   // Som ao bater em asteroide
const bgm = new Audio('bgm.mp3');        // Música de fundo
bgm.loop=true; bgm.volume=0.3;          // Loop contínuo e volume baixo

// --- VARIÁVEIS PRINCIPAIS ---
const canvas = document.getElementById('gameCanvas'); // Canvas do jogo
const ctx = canvas.getContext('2d');                  // Contexto de desenho
const gameWidth = canvas.width;                       // Largura do canvas
const gameHeight = canvas.height;                     // Altura do canvas

// Posição do mouse
let mouseX = gameWidth / 2;

// Estado do jogo
let score = 0;        // Pontuação atual
let lives = 3;        // Vidas restantes
let level = 1;        // Nível atual
let fallSpeed = 3;    // Velocidade de queda dos objetos
let spawnInterval = 1000; // Intervalo de spawn de objetos (ms)
let lastSpawn = 0;        // Timestamp do último spawn

// Objetos e partículas
let objects = [];           // Asteroides e estrelas
let starsBackground = [];   // Estrelas do fundo
let asteroidParticles = []; // Partículas de asteroides
let explosionParticles = [];// Partículas de explosão
let selectedLives = 3;      // Vidas escolhidas pelo jogador

// Jogador
const player = {
  x: gameWidth / 2 - 20,  // Posição X inicial
  y: gameHeight - 90,     // Posição Y inicial
  width: 40, height: 60,  // Tamanho da nave
  speed: 10               // Velocidade (não usada no teclado)
};

// Estado do jogo: start, playing, gameover
let gameState = "start";

// --- ELEMENTOS HTML ---
const startScreen = document.getElementById('startScreen');
const lifeInput = document.getElementById('lifeInput');
const startButton = document.getElementById('startButton');
const instructionScreen = document.getElementById('instructionScreen');
const closeInstructions = document.getElementById('closeInstructions');
const hud = document.getElementById('hud');
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const gameOverScreen = document.getElementById('gameOverScreen');
const finalScore = document.getElementById('finalScore');
const restartButton = document.getElementById('restartButton');

// --- EVENTOS ---
// Botão começar: seleciona vidas e mostra instruções
startButton.addEventListener('click', () => {
  let chosen = parseInt(lifeInput.value); // Lê valor do input
  if(isNaN(chosen) || chosen < 1) chosen = 1; // Limite mínimo
  if(chosen > 5) chosen = 5;                 // Limite máximo
  lives = selectedLives = chosen;            // Salva vidas escolhidas
  score = 0; level = 1; fallSpeed = 3; spawnInterval = 1000; objects = []; // Reset game
  startScreen.style.display='none';         // Esconde tela inicial
  instructionScreen.style.display='flex';   // Mostra instruções
});

// Botão fechar instruções: inicia o jogo
closeInstructions.addEventListener('click', () => {
  instructionScreen.style.display='none';
  canvas.style.display='block'; hud.style.display='block';
  createBackgroundStars(100); lastSpawn = Date.now();
  gameState='playing'; bgm.currentTime=0; bgm.play();
  requestAnimationFrame(gameLoop); // Inicia loop do jogo
});

// Botão reiniciar no Game Over
restartButton.addEventListener('click', () => {
  lives = selectedLives; score = 0; level = 1; fallSpeed = 3; spawnInterval = 1000; objects = [];
  asteroidParticles = []; explosionParticles = [];
  createBackgroundStars(100);
  gameOverScreen.style.display='none';
  canvas.style.display='block'; hud.style.display='block';
  gameState='playing'; bgm.currentTime=0; bgm.play();
  requestAnimationFrame(gameLoop);
});

// Movimento do mouse
canvas.addEventListener('mousemove', e=>{
  const rect = canvas.getBoundingClientRect(); // Posição do canvas na tela
  mouseX = e.clientX - rect.left;              // Calcula posição X relativa ao canvas
});

// --- FUNÇÕES ---
// Cria estrelas de fundo com efeito de pulsar
function createBackgroundStars(num) {
  starsBackground = [];
  for(let i=0;i<num;i++){
    starsBackground.push({
      x:Math.random()*gameWidth,
      y:Math.random()*gameHeight,
      size:Math.random()*2+1,        // Tamanho da estrela
      speed:Math.random()*0.5+0.2,   // Velocidade de queda
      alpha:Math.random(),            // Transparência
      pulse:Math.random()*0.05        // Velocidade de pulso de brilho
    });
  }
}

// Desenha o fundo com estrelas pulsantes
function drawBackground(){
  ctx.fillStyle="#222"; ctx.fillRect(0,0,gameWidth,gameHeight); // Fundo escuro
  starsBackground.forEach(star=>{
    star.alpha += star.pulse; if(star.alpha>1||star.alpha<0.2) star.pulse*=-1;
    ctx.beginPath();
    const gradient=ctx.createRadialGradient(star.x,star.y,0,star.x,star.y,star.size*2);
    gradient.addColorStop(0, `rgba(255,255,200,${star.alpha})`);
    gradient.addColorStop(0.5, `rgba(255,255,255,${star.alpha*0.8})`);
    gradient.addColorStop(1,"transparent");
    ctx.fillStyle=gradient;
    ctx.arc(star.x,star.y,star.size*2,0,Math.PI*2); ctx.fill();
    star.y+=star.speed; if(star.y>gameHeight) star.y=0; // Reinicia topo quando passa da tela
  });
}

// --- OBJETOS ---
// Cria novos objetos aleatoriamente (asteroide ou estrela)
function spawnObject(){
  const type=Math.random()<0.7?"asteroid":"star"; // 70% asteroide, 30% estrela
  objects.push({
    x:Math.random()*(gameWidth-50),
    y:-50,
    width:type==="asteroid"?50:30,
    height:type==="asteroid"?50:30,
    type:type
  });
}

// Atualiza posição e colisões dos objetos
function updateObjects(){
  const now = Date.now();
  if(now-lastSpawn>spawnInterval){ spawnObject(); lastSpawn=now; }
  for(let i=objects.length-1;i>=0;i--){
    const obj = objects[i]; obj.y+=fallSpeed;

    // Colisão com jogador
    if(obj.x<player.x+player.width && obj.x+obj.width>player.x &&
       obj.y<player.y+player.height && obj.y+obj.height>player.y){
      if(obj.type==="star"){ 
        score++; 
        starSound.currentTime=0; starSound.play(); 
      } else { 
        lives--; 
        hitSound.currentTime=0; hitSound.play(); 
        spawnExplosionParticles(player.x+player.width/2, player.y+player.height/2); 
        if(lives<=0) gameState='gameover'; 
      }
      objects.splice(i,1); checkLevelUp(); continue;
    }

    if(obj.type==="asteroid") spawnAsteroidParticles(obj.x+obj.width/2, obj.y+obj.height/2);
    if(obj.y>gameHeight) objects.splice(i,1); // Remove objetos fora da tela
  }
}

// Checa se jogador subiu de nível
function checkLevelUp(){
  if(score>0 && score%10===0){ level++; fallSpeed+=0.5; if(spawnInterval>300) spawnInterval-=80; }
}

// --- PARTICULAS ---
function spawnAsteroidParticles(cx,cy,color="#bbb",count=2){ 
  for(let i=0;i<count;i++) asteroidParticles.push({x:cx,y:cy,vx:(Math.random()-0.5)*2,vy:(Math.random()-0.5)*2,size:Math.random()*3+1,color:color,life:25}); 
}
function spawnExplosionParticles(cx,cy,count=20){ 
  for(let i=0;i<count;i++) explosionParticles.push({x:cx,y:cy,vx:(Math.random()-0.5)*4,vy:(Math.random()-0.5)*4,size:Math.random()*4+2,color:`rgba(${Math.floor(Math.random()*255)},${Math.floor(Math.random()*255)},0,1)`,life:40}); 
}
function updateParticles(){ 
  for(let i=asteroidParticles.length-1;i>=0;i--){let p=asteroidParticles[i];p.x+=p.vx;p.y+=p.vy;p.life--; if(p.life<=0) asteroidParticles.splice(i,1); }
  for(let i=explosionParticles.length-1;i>=0;i--){let p=explosionParticles[i];p.x+=p.vx;p.y+=p.vy;p.life--; if(p.life<=0) explosionParticles.splice(i,1); }
}
function drawParticles(){ 
  asteroidParticles.forEach(p=>{ctx.fillStyle=p.color;ctx.beginPath();ctx.arc(p.x,p.y,p.size,0,Math.PI*2);ctx.fill();});
  explosionParticles.forEach(p=>{ctx.fillStyle=p.color;ctx.beginPath();ctx.arc(p.x,p.y,p.size,0,Math.PI*2);ctx.fill();});
}

// --- DESENHO OBJETOS ---
function drawAsteroid(obj){ 
  const cx=obj.x+obj.width/2,cy=obj.y+obj.height/2,r=obj.width/2; 
  ctx.fillStyle="#888"; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill(); 
  ctx.fillStyle="#666"; ctx.beginPath(); ctx.arc(cx-r*0.3,cy-r*0.2,r*0.2,0,Math.PI*2); ctx.fill(); 
  ctx.beginPath(); ctx.arc(cx+r*0.2,cy+r*0.3,r*0.15,0,Math.PI*2); ctx.fill(); 
  ctx.strokeStyle="#555"; ctx.stroke(); 
}
function drawStar(obj){ 
  const cx=obj.x+obj.width/2,cy=obj.y+obj.height/2,spikes=5,outerR=obj.width/2,innerR=outerR/2; 
  let rot=Math.PI/2*3,step=Math.PI/spikes; ctx.fillStyle="gold"; ctx.beginPath(); ctx.moveTo(cx,cy-outerR); 
  for(let i=0;i<spikes;i++){ 
    ctx.lineTo(cx+Math.cos(rot)*outerR,cy+Math.sin(rot)*outerR); rot+=step; 
    ctx.lineTo(cx+Math.cos(rot)*innerR,cy+Math.sin(rot)*innerR); rot+=step; 
  } ctx.closePath(); ctx.fill(); 
}
function drawObjects(){ objects.forEach(o=>o.type==="asteroid"?drawAsteroid(o):drawStar(o)); }

// --- PLAYER ---
function updatePlayer(){
  // Movimento apenas pelo mouse, suave
  player.x += (mouseX - player.x - player.width/2)*0.1;
  if(player.x<0) player.x=0; // Limite esquerda
  if(player.x>gameWidth-player.width) player.x=gameWidth-player.width; // Limite direita
}
function drawPlayer(){
  ctx.fillStyle="gray"; ctx.fillRect(player.x,player.y,player.width,player.height);
  const blink=Math.random()*0.5+0.5;
  ctx.fillStyle=`rgba(0,191,255,${blink})`;
  ctx.fillRect(player.x+player.width*0.3,player.y+player.height*0.1,player.width*0.4,player.height*0.25);
  ctx.fillStyle="red";
  ctx.beginPath(); ctx.moveTo(player.x,player.y+player.height*0.6); ctx.lineTo(player.x-12,player.y+player.height); ctx.lineTo(player.x+player.width*0.5,player.y+player.height*0.7); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(player.x+player.width,player.y+player.height*0.6); ctx.lineTo(player.x+player.width+12,player.y+player.height); ctx.lineTo(player.x+player.width*0.5,player.y+player.height*0.7); ctx.closePath(); ctx.fill();
}

// --- HUD ---
function updateHUD(){ 
  scoreEl.innerText="Pontuação: "+score; 
  livesEl.innerText="Vidas: "+lives; 
}

// --- LOOP PRINCIPAL ---
function gameLoop(){
  if(gameState!=="playing"){ // Se não estiver jogando
    if(gameState==="gameover"){ // Se acabou
      bgm.pause(); canvas.style.display='none'; hud.style.display='none'; gameOverScreen.style.display='flex';
      finalScore.innerText="Pontuação final: "+score;
    }
    return; // Para o loop
  }
  drawBackground();
  updatePlayer();
  updateObjects();
  updateParticles();
  drawObjects();
  drawPlayer();
  drawParticles();
  updateHUD();
  requestAnimationFrame(gameLoop); // Próximo frame
}
</script>
</body>
</html>
